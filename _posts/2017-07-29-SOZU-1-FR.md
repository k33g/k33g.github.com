---

layout: post
title: SOZU, le reverse-proxy magique
info : Comment utiliser SOZU pour faire de la r√©partition de charge, du blue-green deployment "√† la main"
teaser: un premier mode d'emploi de SOZU
---

# Jouer avec S≈çzu - 1ers pas

>  - Objectif de ce blog post: mettre en place un environnement pour pouvoir "jouer" avec **S≈çzu**
>  - Niveau: d√©butant
>  - ce que j'√©cris n'engage que moi bien s√ªr üòÉ
>  - le r√©seau n'est vraiment pas mon domaine üòñ
>  - Nous verrons (rapidement)
>    - comment installer **S≈çzu**
>    - comment l'utiliser pour r√©partir la charge sur plusieurs VMs
>    - comment l'utiliser pour d√©ployer une nouvelle version de site
> Et tout cela de mani√®re transparente mais √† la main ‚úãü§ö pour mieux comprendre

## 1) S≈çzu?

**S≈çzu** est un reverse proxy HTTP d√©velopp√© chez [https://www.clever-cloud.com/](https://www.clever-cloud.com/) qui peut changer sa configuration au runtime, sans re-d√©marrer. Le proxy expose une cha√Æne de communication (communication channel in üá¨üáß) et du coup on peut envoyer des commandes √† chaud √† **S≈çzu**.

Si vous voulez savoir ce qu'est un reverse proxy parce que vous n'y connaissez rien ou presque sur le sujet, je vous conseille cette vid√©o [Comprendre le Proxy et le Reverse Proxy en 5 minutes](https://www.youtube.com/watch?v=MpP02aZPSNQ) par **"Cookie connect√©"**.

Si vous voulez en savoir plus sur **S≈çzu**, je vous conseille la lecture de ce blog post (le comment, le pourquoi de **S≈çzu**): [Hot reloading configuration: why and how?](https://www.clever-cloud.com/blog/engineering/2017/07/24/hot-reloading-configuration-why-and-how/) par [Geoffroy Couprie](https://twitter.com/gcouprie) le papa de **S≈çzu** *(√† qui je n'ai rien fait relire üòú)*

Et le repository GitHub est par ici: [https://github.com/sozu-proxy/sozu](https://github.com/sozu-proxy/sozu)

### ‚ú®‚ú®‚ú® Remerciements pour leurs explications

- [Geoffroy Couprie](https://twitter.com/gcouprie)
- [Arnaud Lefebvre](https://twitter.com/BlackYoup)


## 2) Mise en place du terrain de jeux

- Nous aurons besoin de plusieurs VMs *(virtual machines)*, j'ai choisi d'utiliser:
  - VirtualBox [https://www.virtualbox.org/](https://www.virtualbox.org/)
  - Vagrant [https://www.vagrantup.com/](https://www.vagrantup.com/)
  - ‚ÑπÔ∏è *vous pouvez adapter avec vos outils, l'important c'est de pouvoir simuler plusieurs machines*
  - *Les installations de VirtualBox et Vagrant sont tr√®s simples √† faire*
- Il faudra "builder" **S≈çzu**
  - Nous devront donc installer **Rust** *(car, je le rappelle S≈çzu est cod√© en Rust)*.
  - ‚ö†Ô∏è **S≈çzu** est encore en üöß donc certaines choses peuvent changer

> Qu'allons nous faire?: h√©berger un m√™me code source de site web en **NodeJS** dans plusieurs VMs

Tout d'abord cr√©ez une arborescence pour h√©berger nos exp√©rimentations:

```
sandbox
   ‚îú‚îÄ‚îÄ hello-earth-v1   # ici le code source de mon site web
   ‚îú‚îÄ‚îÄ vms              # le projet Vagrant pour g√©n√©rer et provisionner nos VM
   ‚îú‚îÄ‚îÄ sozu-demo        # ici nous builderons le projet sozu

```

### A) Le code source du site web

> J'ai utilis√© **ExpressJS**. vous allez avoir besoin uniquement de 2 fichiers:
> - `index.js`
> - `package.js`

```
sandbox
   ‚îú‚îÄ‚îÄ hello-earth-v1   
   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
   ‚îÇ   ‚îî‚îÄ‚îÄ package.json   
   ‚îú‚îÄ‚îÄ vms              
   ‚îú‚îÄ‚îÄ sozu-demo        

```

#### index.js

‚ÑπÔ∏è j'utilise la librairie `'project-name-generator'` pour g√©n√©rer un nom de machine diff√©rent pour chacune des VMs.

```javascript
const express = require("express");
const bodyParser = require("body-parser");
const generate = require('project-name-generator');

let port = process.env.PORT || 8080;

let app = express();
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({extended: false}))

let machineName = generate({ words: 3, number: true }).dashed

app.disable('etag');

app.get('/', (req, res) => {
  res.send(`
    <!doctype html>
    <html>
      <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>WebApp</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <style>
        .container
        {
          min-height: 100vh;
          display: flex;
          justify-content: center;
          align-items: center;
          text-align: center;
        }
        .title
        {
          font-family: "Source Sans Pro", "Helvetica Neue", Arial, sans-serif;
          display: block;
          font-weight: 300;
          font-size: 40px;
          color: #35495e;
          letter-spacing: 1px;
        }
        .subtitle
        {
          font-family: "Source Sans Pro", "Helvetica Neue", Arial, sans-serif;
          font-weight: 300;
          font-size: 30px;
          color: #526488;
          word-spacing: 5px;
          padding-bottom: 15px;
        }
        </style>
      </head>
      <body>
        <section class="container">
          <div>
            <h1 class="title">
              üëã I am ${machineName}
            </h1>
            <h2 class="subtitle">
              Hello üåç v1
            </h2>
          </div>
        </section>
      </body>
    </html>
  `)
})

app.listen(port)
console.log(`üåç ${machineName} is started - listening on `, port)
```

#### package.json

```json
{
  "name": "hello-earth",
  "scripts": {
    "start": "node index.js"
  },
  "main": "index.js",
  "dependencies": {
    "body-parser": "^1.17.2",
    "express": "^4.15.3",
    "project-name-generator": "^2.1.3"
  }
}
```

### B) Notre projet Vagrant

> Dans le r√©pertoire `vms`, allez cr√©er un fichier `Vagrantfile`

```
sandbox
   ‚îú‚îÄ‚îÄ hello-earth-v1   
   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
   ‚îÇ   ‚îî‚îÄ‚îÄ package.json   
   ‚îú‚îÄ‚îÄ vms   
   ‚îÇ   ‚îî‚îÄ‚îÄ Vagrantfile               
   ‚îú‚îÄ‚îÄ sozu-demo        

```

#### Vagrantfile

> Que fait le script?
> - je cr√©e 3 VMs √† partie d'une image **`bento/ubuntu-17.04`**
> - chaque VM aura une ip fixe et se nomme `webappN`:
>   - `webapp1` : `192.168.1.21`
>   - `webapp2` : `192.168.1.22`
>   - `webapp3` : `192.168.1.23`
> - j'expose le port `8080` (*vous pourrez donc acc√©der √† la webapp par [http://192.168.1.2N:8080/](http://192.168.1.2N:8080/)*)
> - je copie le code source de `/hello-earth-v1` dans le r√©pertoire `/hello-earth` de la vm
> - j'installe **NodeJS**
> - j'installe les packages n√©cessaires pour faire fonctionner la webapp *(`npm install`)*

```ruby
BOX_IMAGE = "bento/ubuntu-17.04"
NODE_COUNT = 3

Vagrant.configure(2) do |config|
  config.vm.box = BOX_IMAGE

  (1..NODE_COUNT).each do |i|
    config.vm.define "webapp#{i}" do |node|

      node.vm.network :forwarded_port, guest: 8080, host: 9090 + i
      node.vm.network "public_network", ip: "192.168.1.2#{i}", bridge: "en0: Wi-Fi (AirPort)"

      node.vm.provider "virtualbox" do |node|
        node.memory = 256
        node.cpus = 1
      end
      
      node.vm.synced_folder '.', '/vagrant', disabled: true
      node.vm.provision "file", source: "../hello-earth-v1", destination: "hello-earth"
      
      node.vm.provision :shell, inline: <<-SHELL
        echo "üëã Installing NodeJS..."
        apt-get install curl python-software-properties -y
        curl -sL https://deb.nodesource.com/setup_7.x | sudo bash -
        apt-get install nodejs -y
        cd hello-earth
        npm install
        echo "üòú bye! üëãüëãüëã"
      SHELL

    end
  end
end
```

Nous pouvons d√®s maintenant g√©n√©rer les VMs et les d√©marrer ainsi que les webapps.
‚ÑπÔ∏è *Mais, vous n`√™tes pas oblig√©s de le faire tout de suite*.

#### G√©n√©rer (et d√©marrer les VMs) les VM

C'est tout simple:

```shell
cd vms
vagrant up
# ‚è≥ patientez un peu, il faut tout de m√™me r√©cup√©rer l'image de l'OS
```

#### D√©marrer les webapps

Il faut donc d√©marrer les webapps au sein de chaque VM, comme cela:

```shell
vagrant ssh webapp1 -c "cd hello-earth; npm start"&
vagrant ssh webapp2 -c "cd hello-earth; npm start"&
vagrant ssh webapp3 -c "cd hello-earth; npm start"&
```

Vous devriez obtenir cette sortie:

```shell
üåç delirious-flagrant-expert-3862 is started - listening on  8080
üåç stimulating-jazzy-spoon-4201 is started - listening on  8080
üåç knotty-responsible-muscle-3315 is started - listening on  8080
```
‚ÑπÔ∏è *je g√©n√®re un nom al√©atoire pour chaque application pour mieux les reconna√Ætre*.

Vous pouvez d√©j√† tester l'acc√®s aux applications:

- [http://192.168.1.21:8080/](http://192.168.1.21:8080/)
- [http://192.168.1.22:8080/](http://192.168.1.22:8080/)
- [http://192.168.1.23:8080/](http://192.168.1.23:8080/)

Maintenant passons aux choses s√©rieuses üòâ


### C) Installation de S≈çzu

Suivre les √©tapes suivantes (cela peut √™tre un peu long selon a configuration de votre machine):

```shell
# Installer Rust et le tooling associ√©
curl https://sh.rustup.rs -sSf | sh
# wait... ü§î

# cloner S≈çzu
cd sozu-demo
git clone https://github.com/sozu-proxy/sozu

# compiler S≈çzu
cd sozu
cd ctl && cargo build; cd ../bin && cargo build
# wait... ü§î
```

Vous devrier avoir cette arborescence:

```
sandbox
   ‚îú‚îÄ‚îÄ hello-earth-v1   
   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
   ‚îÇ   ‚îî‚îÄ‚îÄ package.json   
   ‚îú‚îÄ‚îÄ vms   
   ‚îÇ   ‚îî‚îÄ‚îÄ Vagrantfile               
   ‚îú‚îÄ‚îÄ sozu-demo  
   ‚îÇ   ‚îî‚îÄ‚îÄ sozu       
```

Dans le r√©pertoire `/sozu/demo` nous allons cr√©er:

- un r√©pertoire `command_folder`
- un fichier vide `state.json`
- un fichier `404.html`
- un fichier `503.html`
- un fichier `demo.toml`

#### 404.html

```html
HTTP/1.1 404 nope
Cache-Control: no-cache
Content-Type: text/html; charset=UTF-8
Connection: close
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="Pragma" content="no-cache">
    <style>
    .title
    {
      font-family: "Source Sans Pro", "Helvetica Neue", Arial, sans-serif;
      display: block;
      font-weight: 300;
      font-size: 60px;
      color: #35495e;
      letter-spacing: 1px;
    }
    </style>
  </head>
  <body>
    <h1 class="title">
      üò° Nope‚ùóÔ∏è
    </h1>
  </body>
</html>
```

#### 503.html

```html
HTTP/1.1 503 your application is in deployment
Cache-Control: no-cache
Content-Type: text/html; charset=UTF-8
Connection: close
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <style>
    .title
    {
      font-family: "Source Sans Pro", "Helvetica Neue", Arial, sans-serif;
      display: block;
      font-weight: 300;
      font-size: 60px;
      color: #35495e;
      letter-spacing: 1px;
    }
    </style>
  </head>
  <body>
    <h1 class="title">
      üò¢ Ouch...
    </h1>
  </body>
</html>

```

#### demo.toml

C'est le fichier de configuration utilis√© par **S≈çzu**

```
# sozu proxy simple demo config file

command_socket = "./command_folder/sock"
saved_state    = "./state.json"
log_level      = "info"
log_target     = "stdout"
command_buffer_size = 16384
worker_count = 2
handle_process_affinity = false

# you need this, but currently it`s not used
[metrics]
address = "192.168.59.103"
port = 8125

[http]
address = "127.0.0.1"
max_connections = 10
port = 9090
buffer_size = 16384
answer_404 = "./404.html"
answer_503 = "./503.html"


[applications]

[applications.webapp]
hostname = "localhost"
frontends = [ "HTTP" ] # list of proxy tags
backends  = [ "192.168.1.21:8080", "192.168.1.22:8080", "192.168.1.22:8080" ] # list of IP/port 
```

Les **2 sections** les plus importantes pour notre "POC" sont `[http]` et [applications.webapp]:

- avec `[http]`, vous pouvez d√©duire que vos allez acc√©der au reverse-proxy via l'ip `127.0.0.1` et le port http `9090`
- avec `[applications.webapp]`, le nom de domaine pour acc√©der au proxy est `"localhost"` et vous serez redirig√©s vers une des machines comprises dans la liste des ip sur un port particulier
- ‚ÑπÔ∏è *dans `[applications.webapp]` c'est vous qui donnez le nom `webapp`, vous l'appelez comme vous voulez*

Maintenant vous devriez avoir cette arborescence:

```
sandbox
   ‚îú‚îÄ‚îÄ hello-earth-v1   
   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
   ‚îÇ   ‚îî‚îÄ‚îÄ package.json   
   ‚îú‚îÄ‚îÄ vms   
   ‚îÇ   ‚îî‚îÄ‚îÄ Vagrantfile               
   ‚îú‚îÄ‚îÄ sozu-demo  
   ‚îÇ   ‚îú‚îÄ‚îÄ 404.html  
   ‚îÇ   ‚îú‚îÄ‚îÄ 503.html   
   ‚îÇ   ‚îú‚îÄ‚îÄ demo.toml   
   ‚îÇ   ‚îú‚îÄ‚îÄ state.json  
   ‚îÇ   ‚îú‚îÄ‚îÄ command_folder/       
   ‚îÇ   ‚îî‚îÄ‚îÄ sozu/      
```

## 3) On joue ... Une 1√®re fois!

> Si vous ne l'avez pas d√©j√† fait, g√©n√©rez vos VM et lancez les webapps

Dans un 1er templ, lancez **S≈çzu**:

```shell
cd sozu-demo
./sozu/target/debug/sozu start -c ./demo.toml
```

### A) 1er contact

Maintenant ouvrez 2 navigateurs diff√©rents (j'ai fait le test avec Chrome et FireFox) avec l'url [http://localhost:9090/](http://localhost:9090/) et vous obtiendrez ceci:

<img src="https://github.com/k33g/k33g.github.com/raw/master/images/sozu01.png" height="95%" width="95%">

Vous pouvez voir que **S≈çzu** vous a redirig√© sur des machines diff√©rentes (pour une seule et m√™me url)

### B) Tuons des VMs

#### Arr√™tons 2 VMs:

```shell
# obtenir la liste des VMs
cd vms
vagrant status

# Vous allez obtenir ceci:
Current machine states:

webapp1                   running (virtualbox)
webapp2                   running (virtualbox)
webapp3                   running (virtualbox)

# arr√™tons webapp2 et webapp3  ... et supprimons les
vagrant halt webapp2; vagrant destroy webapp2 -f
vagrant halt webapp3; vagrant destroy webapp3 -f

vagrant status
# nouveau status
webapp1                   running (virtualbox)
webapp2                   not created (virtualbox)
webapp3                   not created (virtualbox)

```

- Raffraichissez vos navigateurs
- Il va falloir attendre un peu: **S≈çzu** dispose d'un **circuit-breaker** qui va tenter pendant un petit moment de joindre les 2 machines "disparues"
- puis **S≈çzu** va "se rabattre" sur la machine restante

Et vous devriez obtenir ceci *(j'ai fait un test suppl√©mentaire avec Safari)*: 

<img src="https://github.com/k33g/k33g.github.com/raw/master/images/sozu02.png" height="95%" width="95%">

#### Arr√™tons la derni√®re VM

```shell
vagrant halt webapp1; vagrant destroy webapp1 -f
```

- Raffraichissez vos navigateurs
- Attendez un peu... (selon les navigateurs et leur cache, les comportements peuvent √™tre variables)

Et vous devriez obtenir notre favuleuse page 503:

<img src="https://github.com/k33g/k33g.github.com/raw/master/images/sozu03.png" height="95%" width="95%">

## 4) On relance les sites

Alors on recr√©e les VMs une nouvelle fois, on d√©marre les webapps:

```shell
cd vms
vagrant up
```

Et vous relancez la webapp **ExpressJS** de la 1√®re VM:

```shell
vagrant ssh webapp1 -c "cd hello-earth; npm start"
````

Ensuite nous allons "expliquer" √† **Sozu** que nous avons une nouvelle machine √† nouveau disponible en lui passant la commande suivante:

```shell
cd sozu-demo
./sozu/target/debug/sozuctl --config ./demo.toml  backend add --id webapp --ip 192.168.1.21 --port 8080
```

- Raffraichissez vos navigateurs
- Attendez un peu... 
- Et ü•Åü•Åü•Å

<img src="https://github.com/k33g/k33g.github.com/raw/master/images/sozu04.png" height="95%" width="95%">

**Et ceci sans red√©marrer S≈çzu üòçü§ó**

Relancez les autres webapps:

```shell
vagrant ssh webapp2 -c "cd hello-earth; npm start"&
vagrant ssh webapp3 -c "cd hello-earth; npm start"&
````

Expliquons √† **S≈çzu** qu'il y a nouveau des machines suppl√©mentaires:

```shell
./sozu/target/debug/sozuctl --config ./demo.toml  backend add --id webapp --ip 192.168.1.22 --port 8080
```

puis

```shell
./sozu/target/debug/sozuctl --config ./demo.toml  backend add --id webapp --ip 192.168.1.23 --port 8080
```

- Raffraichissez vos navigateurs
- Et voil√†: 

<img src="https://github.com/k33g/k33g.github.com/raw/master/images/sozu05.png" height="95%" width="95%">

## 5) On fait une mise √† jour de site

J'ai cr√©√© une nouvelle version du site dans un r√©pertoire `/hello-earth-v2` avec une √©volution **majeure**, j'ai modifi√© une partie du code html:

```html
<body>
  <section class="container">
    <div>
      <h1 class="title">
        üëã I am ${machineName} I ‚ù§Ô∏è üêº
      </h1>
      <h2 class="subtitle">
        Hello üåç v2
      </h2>
    </div>
  </section>
</body>
```

### A) Nouveau projet Vagrant

Je vais donc cr√©er de nouvelles VMs dans un r√©p√©ertoire `/vms-new `

```
sandbox
   ‚îú‚îÄ‚îÄ hello-earth-v1   
   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
   ‚îÇ   ‚îî‚îÄ‚îÄ package.json   
   ‚îú‚îÄ‚îÄ hello-earth-v2  
   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
   ‚îÇ   ‚îî‚îÄ‚îÄ package.json      
   ‚îú‚îÄ‚îÄ vms   
   ‚îÇ   ‚îî‚îÄ‚îÄ Vagrantfile   
   ‚îú‚îÄ‚îÄ vms-new   
   ‚îÇ   ‚îî‚îÄ‚îÄ Vagrantfile                 
   ‚îú‚îÄ‚îÄ sozu-demo       
   ‚îÇ   ‚îî‚îÄ‚îÄ sozu/      
```

... Avec un nouveau `Vagrantfile`

> - chaque VM aura une nouvelle ip fixe et se nomme `webapp_newN`:
>   - `webapp1` : `192.168.1.31`
>   - `webapp2` : `192.168.1.32`
>   - `webapp3` : `192.168.1.33`
> - je copie le code source de `/hello-earth-v2` dans le r√©pertoire `/hello-earth` de la vm


```ruby
BOX_IMAGE = "bento/ubuntu-17.04"
NODE_COUNT = 3

Vagrant.configure(2) do |config|
  config.vm.box = BOX_IMAGE

  (1..NODE_COUNT).each do |i|
    config.vm.define "webapp_new#{i}" do |node|

      node.vm.network :forwarded_port, guest: 8080, host: 9100 + i
      node.vm.network "public_network", ip: "192.168.1.3#{i}", bridge: "en0: Wi-Fi (AirPort)"

      node.vm.provider "virtualbox" do |node|
        node.memory = 256
        node.cpus = 1
      end
      
      node.vm.synced_folder '.', '/vagrant', disabled: true
      node.vm.provision "file", source: "../hello-earth-v2", destination: "hello-earth"
      
      node.vm.provision :shell, inline: <<-SHELL
        echo "üëã Installing NodeJS..."
        apt-get install curl python-software-properties -y
        curl -sL https://deb.nodesource.com/setup_7.x | sudo bash -
        apt-get install nodejs -y
        cd hello-earth
        npm install
        echo "üòú bye! üëãüëãüëã"
      SHELL

    end
  end
end
```

### B) Cr√©ation, provisionning et lancement

On provisionne donc les nouvelles machines:

```shell
vagrant up
# puis
vagrant ssh webapp_new1 -c "cd hello-earth; npm start"
vagrant ssh webapp_new2 -c "cd hello-earth; npm start"
vagrant ssh webapp_new3 -c "cd hello-earth; npm start"
```

On "üëã notifie" **S≈çzu** de l'arriv√©e de nouvelles machines


```shell
./sozu/target/debug/sozuctl --config ./demo.toml  backend add --id webapp --ip 192.168.1.31 --port 8080
./sozu/target/debug/sozuctl --config ./demo.toml  backend add --id webapp --ip 192.168.1.32 --port 8080
./sozu/target/debug/sozuctl --config ./demo.toml  backend add --id webapp --ip 192.168.1.33 --port 8080
```

Ensuite on "üëã notifie" **S≈çzu** du d√©part des anciennes machines (cette fois √ßi avec le mot-cl√© `remove`)

```shell
./sozu/target/debug/sozuctl --config ./demo.toml  backend remove --id webapp --ip 192.168.1.21 --port 8080
./sozu/target/debug/sozuctl --config ./demo.toml  backend remove --id webapp --ip 192.168.1.22 --port 8080
./sozu/target/debug/sozuctl --config ./demo.toml  backend remove --id webapp --ip 192.168.1.23 --port 8080
```

- Raffraichissez vos navigateurs
- Attendez un peu... 
- Et ‚ú®üêø le nouveau site a √©t√© d√©plot√© sans aucun arr√™t relance üï∫

<img src="https://github.com/k33g/k33g.github.com/raw/master/images/sozu06.png" height="95%" width="95%">

Voil√†, c'est tout pour aujourd'hui. **S≈çzu** √©volue et de nouvelles fonctionnalit√©s sont √† venir. Et de mon c√¥t√© je pense d√©j√† au prochain tuto **S≈çzu** avec des microservices **Vert.x**.
